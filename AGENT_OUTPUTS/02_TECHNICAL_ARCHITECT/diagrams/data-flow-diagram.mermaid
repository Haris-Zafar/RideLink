graph TB
    subgraph "Scenario 1: User Registration & Verification"
        U1[User]
        U1 -->|1. Submit registration form| F1[React Form]
        F1 -->|2. POST /auth/register| API1[Auth Controller]
        API1 -->|3. Validate input| V1[Validation Middleware]
        V1 -->|4. Create user| S1[Auth Service]
        S1 -->|5. Hash password| BC1[bcrypt]
        S1 -->|6. Save to DB| M1[User Model]
        M1 -->|7. Insert| DB1[(MongoDB)]
        S1 -->|8. Send verification email| SG1[SendGrid]
        SG1 -.->|9. Email sent| U1
        API1 -->|10. Return success| F1
        F1 -->|11. Show success message| U1
        
        U1 -->|12. Request phone OTP| F2[React Component]
        F2 -->|13. POST /auth/verify-phone/send| API2[Auth Controller]
        API2 -->|14. Generate OTP| S2[Auth Service]
        S2 -->|15. Save OTP to DB| DB1
        S2 -->|16. Send SMS| TW1[Twilio]
        TW1 -.->|17. SMS delivered| U1
        
        U1 -->|18. Enter OTP code| F3[Verification Form]
        F3 -->|19. POST /auth/verify-phone/verify| API3[Auth Controller]
        API3 -->|20. Verify OTP| S3[Auth Service]
        S3 -->|21. Update phoneVerified| DB1
        API3 -->|22. Return JWT token| F3
        F3 -->|23. Store token & redirect| U1
    end

    subgraph "Scenario 2: Search & Book a Ride"
        U2[Passenger]
        U2 -->|1. Enter search criteria| F4[Search Form]
        F4 -->|2. GET /rides/search?origin=...| API4[Ride Controller]
        API4 -->|3. Build query| S4[Ride Service]
        S4 -->|4. Query with indexes| M2[Ride Model]
        M2 -->|5. Find matching rides| DB2[(MongoDB)]
        DB2 -->|6. Return results| M2
        M2 -->|7. Populate driver info| M3[User Model]
        S4 -->|8. Format response| API4
        API4 -->|9. Return JSON| F4
        F4 -->|10. Display ride cards| U2
        
        U2 -->|11. Click ride details| F5[Ride Details Page]
        F5 -->|12. GET /rides/:id| API5[Ride Controller]
        API5 -->|13. Fetch ride| S5[Ride Service]
        S5 -->|14. Get route from cache/API| G1[Google Maps API]
        G1 -.->|15. Return route data| S5
        API5 -->|16. Return full details| F5
        F5 -->|17. Show map & info| U2
        
        U2 -->|18. Click 'Request to Join'| F6[Booking Form]
        F6 -->|19. POST /bookings| API6[Booking Controller]
        API6 -->|20. Validate JWT| AUTH1[Auth Middleware]
        AUTH1 -->|21. Check verification| S6[Booking Service]
        S6 -->|22. Check seat availability| M2
        S6 -->|23. Create booking| M4[Booking Model]
        M4 -->|24. Save| DB2
        S6 -->|25. Notify driver| N1[Notification Service]
        N1 -->|26. Create notification| M5[Notification Model]
        N1 -->|27. Send push notification| WS1[Socket.io]
        WS1 -.->|28. Real-time alert| DRIVER[Driver]
        N1 -->|29. Send SMS| TW2[Twilio]
        TW2 -.->|30. SMS sent| DRIVER
        API6 -->|31. Return success| F6
        F6 -->|32. Show pending status| U2
    end

    subgraph "Scenario 3: Driver Accepts Booking"
        DRIVER2[Driver]
        DRIVER2 -->|1. Open notifications| F7[Dashboard]
        F7 -->|2. GET /bookings/requests| API7[Booking Controller]
        API7 -->|3. Fetch pending requests| S7[Booking Service]
        S7 -->|4. Query bookings| M4
        M4 -->|5. Get with passenger info| DB3[(MongoDB)]
        API7 -->|6. Return requests| F7
        F7 -->|7. Display request list| DRIVER2
        
        DRIVER2 -->|8. Click 'Accept'| F8[Accept Button]
        F8 -->|9. POST /bookings/:id/accept| API8[Booking Controller]
        API8 -->|10. Validate ownership| AUTH2[Auth Middleware]
        AUTH2 -->|11. Update booking| S8[Booking Service]
        S8 -->|12. Set status=confirmed| M4
        M4 -->|13. Save| DB3
        S8 -->|14. Update ride.passengers| M2
        M2 -->|15. Decrement availableSeats| DB3
        S8 -->|16. Notify passenger| N2[Notification Service]
        N2 -->|17. Socket.io event| WS2[WebSocket]
        WS2 -.->|18. booking-confirmed| U2
        N2 -->|19. Send SMS| TW3[Twilio]
        TW3 -.->|20. SMS delivered| U2
        API8 -->|21. Return success| F8
        F8 -->|22. Update UI| DRIVER2
    end

    subgraph "Scenario 4: Real-time Chat"
        PASS[Passenger]
        PASS -->|1. Type message| F9[Chat Input]
        F9 -->|2. Socket: send-message| WS3[Socket.io Server]
        WS3 -->|3. Validate JWT| AUTH3[Socket Auth]
        AUTH3 -->|4. Save message| S9[Chat Service]
        S9 -->|5. Create message doc| M6[Message Model]
        M6 -->|6. Insert| DB4[(MongoDB)]
        S9 -->|7. Emit to driver| WS3
        WS3 -.->|8. Socket: new-message| DRV[Driver]
        DRV -->|9. Message appears| F10[Chat UI]
        
        DRV -->|10. Type reply| F10
        F10 -->|11. Socket: send-message| WS3
        WS3 -->|12. Save & emit| S9
        S9 -->|13. Emit to passenger| WS3
        WS3 -.->|14. Socket: new-message| PASS
        PASS -->|15. Reply appears| F9
    end

    subgraph "Scenario 5: Background Jobs - Recurring Rides"
        CRON[Node-Cron]
        CRON -->|1. Trigger at midnight| JOB1[Generate Recurring Rides Job]
        JOB1 -->|2. Find active schedules| M7[RecurringSchedule Model]
        M7 -->|3. Query active=true| DB5[(MongoDB)]
        DB5 -->|4. Return schedules| M7
        JOB1 -->|5. For each schedule| LOOP{Loop}
        LOOP -->|6. Check if ride exists for tomorrow| M2
        M2 -->|7. Query by date| DB5
        LOOP -->|8. If not exists, create| M2
        M2 -->|9. Insert new ride| DB5
        LOOP -->|10. Update schedule.generatedRides| M7
        M7 -->|11. Save| DB5
        JOB1 -->|12. Log completion| LOG[Logger]
    end

    subgraph "Scenario 6: Admin Reviews Report"
        ADMIN[Admin]
        ADMIN -->|1. Open reports dashboard| F11[Admin Panel]
        F11 -->|2. GET /admin/reports| API9[Admin Controller]
        API9 -->|3. Check admin role| AUTH4[Auth Middleware]
        AUTH4 -->|4. Fetch reports| S10[Admin Service]
        S10 -->|5. Query reports| M8[Report Model]
        M8 -->|6. Get with user info| DB6[(MongoDB)]
        API9 -->|7. Return reports list| F11
        F11 -->|8. Display table| ADMIN
        
        ADMIN -->|9. Click report details| F12[Report Details]
        F12 -->|10. GET /admin/reports/:id| API9
        API9 -->|11. Fetch full report| S10
        API9 -->|12. Return data| F12
        F12 -->|13. Show evidence & details| ADMIN
        
        ADMIN -->|14. Select action: 'Suspend User'| F13[Action Form]
        F13 -->|15. POST /admin/users/:id/suspend| API10[Admin Controller]
        API10 -->|16. Update user status| S11[User Service]
        S11 -->|17. Set status=suspended| M3
        M3 -->|18. Save| DB6
        S11 -->|19. Resolve report| M8
        M8 -->|20. Update status=resolved| DB6
        S11 -->|21. Send notification to user| N3[Notification Service]
        N3 -.->|22. Email sent| REPORTED[Reported User]
        API10 -->|23. Return success| F13
        F13 -->|24. Update UI| ADMIN
    end

    %% Styling
    classDef userNode fill:#3b82f6,stroke:#1e40af,color:#fff
    classDef frontendNode fill:#10b981,stroke:#059669,color:#fff
    classDef backendNode fill:#f59e0b,stroke:#d97706,color:#fff
    classDef databaseNode fill:#ef4444,stroke:#dc2626,color:#fff
    classDef externalNode fill:#8b5cf6,stroke:#7c3aed,color:#fff
    classDef jobNode fill:#ec4899,stroke:#db2777,color:#fff

    class U1,U2,PASS,DRV,DRIVER,DRIVER2,ADMIN,REPORTED userNode
    class F1,F2,F3,F4,F5,F6,F7,F8,F9,F10,F11,F12,F13 frontendNode
    class API1,API2,API3,API4,API5,API6,API7,API8,API9,API10,AUTH1,AUTH2,AUTH3,AUTH4,S1,S2,S3,S4,S5,S6,S7,S8,S9,S10,S11,M1,M2,M3,M4,M5,M6,M7,M8,V1,BC1,N1,N2,N3,WS1,WS2,WS3 backendNode
    class DB1,DB2,DB3,DB4,DB5,DB6 databaseNode
    class SG1,TW1,TW2,TW3,G1 externalNode
    class CRON,JOB1,LOOP,LOG jobNode